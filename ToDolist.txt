1- agregar estructura de DB(SQLite) (ok!)
2- Estructura de modelo: 
    (user:{name, password, role}, 
    log:{ DateTime, LogLevel, microservice, message} 
    )  (ok!)
3- crear seccion cargar archivo txt y procesarlo(sacar cada componente a travez de Regex) y guardar en DB

4- crear page de login(default: regular user)

5- generar dashboard para el admin(despues del login) (semiestructurado!)



//
import { NextResponse } from "next/server";
import { getToken } from "next-auth/jwt";

export async function middleware(req: NextRequest) {
  const token = await getToken({ req });
  const url = req.nextUrl.clone();

  if (!token) {
    url.pathname = "/login";
    return NextResponse.redirect(url);
  }

  const isAdminRoute = url.pathname.startsWith("/admin");
  if (isAdminRoute && token.role !== "admin") {
    url.pathname = "/403"; // Página de acceso denegado
    return NextResponse.redirect(url);
  }

  return NextResponse.next();
}

export const config = {
  matcher: ["/admin/:path*", "/dashboard/:path*"], // Rutas protegidas
};


// 
ver auth de next
generate la parte basica de los archivos logs ademas de next-auth
no eliminar los LOGS pero si editarlo

pedir a chatGPT que me genere un txt con el formato de LOGS!

///

Hooks comunes: Para la lógica de negocio, como fetching o procesamiento de datos.
Ejemplo: useFetchLogs, useFilters.
Componentes UI reutilizables: Como una tabla genérica o un formulario.
Ejemplo: <LogsTable data={logs} />, <Filters onFilter={handleFilter} />.

////

<Table.Cell>
                <span
                  className={`px-2 py-1 rounded ${
                    log.level === "ERROR" ? "bg-red-100 text-red-700" :
                    log.level === "WARNING" ? "bg-yellow-100 text-yellow-700" : "bg-green-100 text-green-700"
                  }`}
                >
                  {log.level}
                </span>
              </Table.Cell>